When you run the consumer and producer concurrently, if you kill the producer, the consumer program will print an error which claims it is a success, but does not since the producer is not running anymore therefore it has nothing to receive.  When the consumer program is exited, the producer program prints an error which states that there is a broken pipe, which happens because the producer/consumer dependency has been broken.  When you run multiple consumers at once with a producer, the producer gices the output to one consumer over the other, sometimes printing at the same time, but mostly they switch on and off because they become ready at different points.  When multiple producers are run, the consumer receives the statement lines equalling the amount of producers running.  When you run multiples of each at the same time, if they are the same number, i.e 2 producers and 2 consumers, they will print concurrently as each producer and consumer have a 1-1 relationship.  However, when that balance is broken, they will begin to behave similarly to the previous examples, depending on how skewed that balance is.  

I believe the solution to this issue will be to use semaphores or locks to determine when these tasks can be received and issued, and to avoid a full pipe problem. 